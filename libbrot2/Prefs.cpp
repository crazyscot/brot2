/*
    Prefs.cpp: Persistent preferences abstraction layer
    Copyright (C) 2011 Ross Younger

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Prefs.h"

#include <string>
#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <glibmm/keyfile.h>
#include <glibmm/fileutils.h>

class KeyfilePrefs;

#define META_GROUP "meta"
#define KEY_VERSION "version"
#define CURRENT_VERSION 1

#define GROUP_FOO "foo_group"
#define KEY_FOO "foo"

int Prefs::default_foo() {
	return 42;
}

class KeyfilePrefs : public Prefs {
	private:
		Glib::KeyFile kf;

	protected:
		~KeyfilePrefs() {
			// Do NOT commit here.
		}

		std::string filename(bool temp=false) {
			std::string rv("");
			char *home = getenv("HOME");
			if (home != NULL)
				rv = rv + home + '/';
			rv = rv + ".brot2";
			if (temp)
				rv = rv + ".tmp";
			return rv;
		}

	public:
		KeyfilePrefs() throw(std::string) {
			kf.set_comment("generated by brot2");
			kf.set_integer(META_GROUP, KEY_VERSION, CURRENT_VERSION);

			std::string fn = filename();
			try {
				kf.load_from_file(fn);
			} catch (Glib::FileError e) {
				switch (e.code()) {
					case Glib::FileError::Code::NO_SUCH_ENTITY:
						break; // ignore, use defaults only
					default:
						std::cerr << "read gave " << e.code() << std::endl;//XXX
						std::string oops = "reading prefs from " + fn + ": " + e.what();
						throw oops;
				}
			} catch (Glib::KeyFileError e) {
				// Catch empty files.
				std::string oops = "KeyFileError reading prefs from " + fn + ": " + e.what();
						throw oops;
			}
		}

		virtual void commit() throw(std::string) {
			int rv;
			std::string fn = filename(true); // write to foo.tmp
			std::ofstream f;

			rv = unlink(fn.c_str());
			if (rv==-1) {
				switch(errno) {
					case ENOENT: 
						break; //ignore
					default:
						std::string oops = "Could not unlink " + fn + ": " + strerror(errno);
						throw oops;
				}
			}
			f.open(fn);
			kf.set_comment("written by brot2");
			f << kf.to_data();
			f.close();

			// And rename new on top of old.
			std::string newfn = filename();
			rv = rename(fn.c_str(), newfn.c_str());
			if (rv==-1) {
				std::string oops = "Could not rename " + fn + " to " + newfn + ": " + strerror(errno);
				throw oops;
			}
		}

		virtual int foo() {
			try {
				return kf.get_integer(GROUP_FOO, KEY_FOO);
			} catch (Glib::KeyFileError e) {
				int def = Prefs::default_foo();
				foo(def);
				return def;
			}
		}
		virtual void foo(int newfoo) {
			kf.set_integer(GROUP_FOO, KEY_FOO, newfoo);
		}
};

namespace {
	KeyfilePrefs *gtkPrefs = 0;
};

// Default accessor, singleton-like.
Prefs& Prefs::getDefaultInstance() throw (std::string) {
	if (gtkPrefs == NULL)
		gtkPrefs = new KeyfilePrefs();
	return *gtkPrefs;
};

Prefs::Prefs() { }
Prefs::~Prefs() { }

